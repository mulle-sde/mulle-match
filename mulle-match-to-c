#! /usr/bin/env bash
#
#   Copyright (c) 2020 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
# Create fresh HeadersAndSources.cmake from filesystem information
#
[ "${TRACE}" = 'YES' ] && set -x && : "$0" "$@"


MULLE_EXECUTABLE_VERSION="0.7.0"


usage()
{
   if [ ! -z "$1" ]
   then
      log_error "$1"
   fi

   cat <<EOF >&2
Usage:
   ${MULLE_USAGE_NAME} [options]

   Generate exportable #import and include statements for public
   project headers.

   The resulting file can be easily included into an envelope header with:

      #import "_${PROJECT_NAME}-include-public.h"
      #include "_${PROJECT_NAME}-import-public.h"

   A test run that writes to stdout and does not create files can be
   accomplished with:
      ${MULLE_USAGE_NAME} --stdout

Options:
   --c-headers-file <file>    : c header file to create
   --filter-type <name>       : the patternfile to use (source)
   --objc-headers-file <file> : objc headers file to create
   --serial                   : process headers and sources serially
   --stdout                   : output to stdout

Environment:
   MULLE_MATCH_TO_C_C_HEADERS_FILE     : C headers file to create
   MULLE_MATCH_TO_C_OBJC_HEADERS_FILE  : ObjC headers file to create

EOF
   exit 1
}



r_statements_for_matching_headers()
{
   local categorized_files="$1"
   local match_category="$2"
   local match_type="$3"
   local projectname="$4"

   local line
   local result
   local category
   local header

   IFS=$'\n'
   set -f

   for line in ${categorized_files}
   do
      category="${line%%;*}"
      header="${line##*;}"

      log_debug "category: ${category}"
      log_debug "header: ${header}"

      case "${category}" in
         ${match_category})
         ;;

         *)
            continue
         ;;
      esac

      # ignore reflected headers
      case "${header}" in
         */reflect/*)
            continue
         ;;
      esac

      r_basename "${header}"
      filename="${RVAL}"

      case "${filename}" in
         # underscore files should be included by other files if they are
         # public and relevant
         _*|*[+-]_*)
            if [ "${MULLE_MATCH_TO_C_UNDERSCORE_HEADERS}" = 'NO' ]
            then
               continue
            fi
         ;;
      esac

      case "${filename}" in
         # this is the file including us
         "${projectname}".h)
            continue
         ;;

         [A-Z]*|_[A-Z]*|_[_]*[A-Z]*)
            if [ "${match_type}" != "objc" ]
            then
               continue
            fi
         ;;

         *)
            if [ "${match_type}" != "c" ]
            then
               continue
            fi
         ;;
      esac

      if [ "${match_type}" = "c" ]
      then
         r_add_line "${result}" "#include \"${filename}\""
      else
         r_add_line "${result}" "#import \"${filename}\""
      fi
      result="${RVAL}"
   done

   IFS="${DEFAULT_IFS}"
   set +f

   RVAL="${result}"
}

r_text_info_on()
{
   local key="$1"

   RVAL="/*
 *   This file will be regenerated by \`mulle-match-to-c\` via
 *   \`mulle-sde reflect\` and any edits will be lost.
 *   Suppress generation of this file with:
 *      mulle-sde environment --global \\
 *         set ${key} DISABLE
 *
 *   To not generate any header files:
 *      mulle-sde environment --global \\
 *         set MULLE_MATCH_TO_C_RUN DISABLE
 */"
}



write_header_file()
{
   log_entry "write_header_file" "$@"

   local filename="$1"
   local text_hdr="$2"
   local projectname="$3"
   local varname="$4"

   r_text_info_on "${varname}"
   text_hdr="${RVAL}"

   log_verbose "Writing ${C_RESET_BOLD}${filename}"
   r_dirname "${filename}"
   mkdir_if_missing "${RVAL}"
   exekutor chmod ug+w "${filename}"  2> /dev/null
   r_mkdir_parent_if_missing "${filename}"
   redirect_exekutor "${filename}" printf "%s\n" "${text_hdr}"
   exekutor chmod a-w "${filename}"
}


create_c_headers_file()
{
   log_entry "create_c_headers_file" "$@"

   local categorized_files="$1"
   local projectname="$2"

   local text_hdr

   case "${MULLE_MATCH_TO_C_C_HEADERS_FILE}" in
      DISABLE*)
         log_verbose "Header generation disabled by MULLE_MATCH_TO_C_C_HEADERS_FILE=DISABLE"
         return
      ;;

      NONE)
         text_hdr="# Header generation disabled by MULLE_MATCH_TO_C_C_HEADERS_FILE=NONE"
         MULLE_MATCH_TO_C_C_HEADERS_FILE=""
      ;;

      *)
         r_statements_for_matching_headers "${categorized_files}" \
                                           "PUBLIC_HEADERS" \
                                           "c" \
                                           "${projectname}"
         text_hdr="${RVAL}"

         if [ -z "${text_hdr}" ]
         then
            text_hdr="// no headers"
         fi
      ;;
   esac

   if [ "${MULLE_MATCH_TO_C_C_HEADERS_FILE}" = '-' ]
   then
   	log_info "C Public Headers"
   	printf "%s\n" "${text_hdr}"
   	return 0
   fi

   MULLE_MATCH_TO_C_C_HEADERS_FILE="${MULLE_MATCH_TO_C_C_HEADERS_FILE:-${PROJECT_SOURCE_DIR:-src}/reflect/_${projectname}-include-public.h}"

   log_fluff "Create public C header files (${PWD})"

   write_header_file "${MULLE_MATCH_TO_C_C_HEADERS_FILE}" \
                     "${text_hdr}" \
                     "${projectname}" \
                     'MULLE_MATCH_TO_C_C_HEADERS_FILE'
}



create_objc_headers_file()
{
   log_entry "create_objc_headers_file" "$@"

   local categorized_files="$1"
   local projectname="$2"

   local text_hdr

   case "${MULLE_MATCH_TO_C_OBJC_HEADERS_FILE}" in
      DISABLE*)
         log_verbose "Header generation disabled by MULLE_MATCH_TO_C_OBJC_HEADERS_FILE=DISABLE"
         return
      ;;

      NONE)
         text_hdr="# Header generation disabled by MULLE_MATCH_TO_C_OBJC_HEADERS_FILE=NONE"
         MULLE_MATCH_TO_C_OBJC_HEADERS_FILE=""
      ;;

      *)
         r_statements_for_matching_headers "${categorized_files}" \
                                           "PUBLIC_HEADERS" \
                                           "objc" \
                                           "${projectname}"
         text_hdr="${RVAL}"

         if [ -z "${text_hdr}" ]
         then
            text_hdr="// no headers"
         fi
      ;;
   esac

   if [ "${MULLE_MATCH_TO_C_OBJC_HEADERS_FILE}" = '-' ]
   then
      log_info "ObjC Public Headers"
      printf "%s\n" "${text_hdr}"
      return 0
   fi

   MULLE_MATCH_TO_C_OBJC_HEADERS_FILE="${MULLE_MATCH_TO_C_OBJC_HEADERS_FILE:-${PROJECT_SOURCE_DIR:-src}/reflect/_${projectname}-import-public.h}"

   log_fluff "Create public Objective-C header files (${PWD})"

   write_header_file "${MULLE_MATCH_TO_C_OBJC_HEADERS_FILE}" \
                     "${text_hdr}" \
                     "${projectname}" \
                     'MULLE_MATCH_TO_C_OBJC_HEADERS_FILE'
}


main()
{
   log_entry "main" "$@"

   # technical flags
   local MULLE_TRACE
   local MULLE_FLAG_DONT_DEFER='NO'
   local MULLE_FLAG_EXEKUTOR_DRY_RUN='NO'
   local MULLE_FLAG_FOLLOW_SYMLINKS='YES'
   local MULLE_FLAG_LOG_CACHE='NO'
   local MULLE_FLAG_LOG_DEBUG='NO'
   local MULLE_FLAG_LOG_EXEKUTOR='NO'
   local MULLE_FLAG_LOG_FLUFF='NO'
   local MULLE_FLAG_LOG_MERGE='NO'
   local MULLE_FLAG_LOG_SCRIPTS='NO'
   local MULLE_FLAG_LOG_SETTINGS='NO'
   local MULLE_FLAG_LOG_VERBOSE='NO'
   local MULLE_TRACE_PATHS_FLIP_X='NO'
   local MULLE_TRACE_POSTPONE='NO'
   local MULLE_TRACE_RESOLVER_FLIP_X='NO'
   local MULLE_TRACE_SETTINGS_FLIP_X='NO'

   local OPTION_PARALLEL='YES'
   local OPTION_C_PUBLIC_HEADERS='DEFAULT'
   local OPTION_OBJC_PUBLIC_HEADERS='DEFAULT'

   MULLE_MATCH_TO_C_PATTERNFILETYPE="${MULLE_MATCH_TO_C_PATTERNFILETYPE:-source}"
   MULLE_MATCH_TO_C_UNDERSCORE_HEADERS="${MULLE_MATCH_TO_C_UNDERSCORE_HEADERS:-NO}"

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -h*|--help|help)
            usage
         ;;

         --parallel|--no-serial)
            OPTION_PARALLEL='YES'
         ;;

         --serial|--no-parallel)
            OPTION_PARALLEL='NO'
         ;;

         --c-headers)
            OPTION_C_PUBLIC_HEADERS='YES'
         ;;

         --no-c-headers)
				OPTION_C_PUBLIC_HEADERS='NO'
			;;

         --objc-headers)
            OPTION_OBJC_PUBLIC_HEADERS='YES'
         ;;

         --no-objc-headers)
            OPTION_OBJC_PUBLIC_HEADERS='NO'
         ;;

         --underscore-headers)
            MULLE_MATCH_TO_C_UNDERSCORE_HEADERS='YES'
         ;;

         --no-underscore-headers)
            MULLE_MATCH_TO_C_UNDERSCORE_HEADERS='NO'
         ;;

         -H|--c-headers-file)
            [ $# -eq 1 ] && usage "missing argument to $1"
            shift

				MULLE_MATCH_TO_C_C_HEADERS_FILE="$1"
			;;

         --objc-headers-file)
            [ $# -eq 1 ] && usage "missing argument to $1"
            shift

            MULLE_MATCH_TO_C_OBJC_HEADERS_FILE="$1"
         ;;

         -F|--filter-type)
            [ $# -eq 1 ] && usage "missing argument to $1"
            shift

            MULLE_MATCH_TO_C_PATTERNFILETYPE="$1"
         ;;

         --stdout)
            OPTION_PARALLEL='NO'
            MULLE_MATCH_TO_C_C_HEADERS_FILE="-"
            MULLE_MATCH_TO_C_OBJC_HEADERS_FILE="-"
         ;;

         --version)
            printf "%s\n" "${MULLE_EXECUTABLE_VERSION}"
            return 0
         ;;

         -*)
            usage "Unknown option \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}"

   [ $# -ne 0 ] && usage "superflous arguments $*"

   MULLE_MATCH="${MULLE_MATCH:-`command -v mulle-match`}"
   [ -z "${MULLE_MATCH}" ] && fail "mulle-match not in PATH"

   #
   # With 1000 header and 1000 source files, a full update takes ~7s on
   # my machine. It certainly would be interesting to make this properly
   # incremental.
   #
   local categorized_files

   if ! categorized_files="`rexekutor "${MULLE_MATCH}" \
                                          ${MULLE_TECHNICAL_FLAGS} \
                                       find --format "%C;%f\\n" \
                                            --match-filter "${MULLE_MATCH_TO_C_PATTERNFILETYPE}"`"
   then
      return 1
   fi

   if [ -z "${categorized_files}" ]
   then
      log_warning "No matching source files found. " >&2
      # exit 0 # but still create empty files, otherwise include is unjappy
   fi

   categorized_files="`LC_ALL=C rexekutor sort -d -t';' -k 1,2 <<< "${categorized_files}" `"

   if [ -z "${PROJECT_NAME}" ]
   then
      r_basename "${PWD}"
      PROJECT_NAME="${RVAL}" # could be nicer
   fi

   if [ -z "${PROJECT_IDENTIFIER}" ]
   then
      r_identifier "${PROJECT_IDENTIFIER}"
      PROJECT_IDENTIFIER="${RVAL}"
   fi

   r_lowercase "${PROJECT_IDENTIFIER}"
   PROJECT_DOWNCASE_IDENTIFIER="${RVAL}"

   PROJECT_SOURCE_DIR="${PROJECT_SOURCE_DIR:-.}"
   PROJECT_DIALECT="${PROJECT_DIALECT:-c}"

   if [ "${OPTION_C_PUBLIC_HEADERS}" = 'DEFAULT' ]
   then
      OPTION_C_PUBLIC_HEADERS='YES'
   fi

   if [ "${OPTION_OBJC_PUBLIC_HEADERS}" = 'DEFAULT' -a "${PROJECT_DIALECT}" = "objc" ]
   then
      OPTION_OBJC_PUBLIC_HEADERS='YES'
   fi

   if [ "${OPTION_PARALLEL}" = 'YES' ]
   then
   	if [ "${OPTION_C_PUBLIC_HEADERS}" = 'YES' ]
   	then
      	create_c_headers_file "${categorized_files}" "${PROJECT_NAME}" &
      fi
      if [ "${OPTION_OBJC_PUBLIC_HEADERS}" = 'YES' ]
      then
         create_objc_headers_file "${categorized_files}" "${PROJECT_NAME}" &
      fi

      log_fluff "waiting..."
      wait
      log_fluff 'done!'
   else
      if [ "${OPTION_C_PUBLIC_HEADERS}" = 'YES' ]
      then
         create_c_headers_file "${categorized_files}" "${PROJECT_NAME}"
      fi
      if [ "${OPTION_OBJC_PUBLIC_HEADERS}" = 'YES' ]
      then
         create_objc_headers_file "${categorized_files}" "${PROJECT_NAME}"
      fi
   fi
}


_init()
{
   if [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ]
   then
      MULLE_BASHFUNCTIONS_LIBEXEC_DIR="`mulle-bashfunctions-env "libexec-dir" 2> /dev/null`"
      [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ] && \
         echo "mulle-bashfunctions-env not installed" >&2 && \
         exit 1
   fi

   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-bashfunctions.sh"  || exit 1
}

_init "$@"

quote="'"
args=""
for arg in "$@"
do
   arg="${arg//${quote}/${quote}\"${quote}\"${quote}}"
   args="${args} '${arg}'"
done

unset quote
unset arg

eval main "${MULLE_MATCH_TO_CMAKE_FLAGS}" "${args}"
